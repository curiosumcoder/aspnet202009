@model CategoryIndexViewModel
@using Microsoft.AspNetCore.Http.Extensions

@{
    ViewData["Title"] = "Index";
}

<h1>Index</h1>

<p>
    <a asp-action="Create">Create New</a>
</p>

<div id="processing" data-message="Procesando espere ..."></div>

<form id="form1" asp-antiforgery="false">
    <div class="d-flex flex-column">
        <div>
            <input id="command" asp-for="Command" type="hidden" />
            <input asp-for="Filter.CategoryName" placeholder="Search here ..." />
            <input id="page" asp-for="Paging.Page" type="hidden" />
            <input id="sort" asp-for="Paging.Sort" type="hidden" />
            <input id="sortdir" asp-for="Paging.SortDir" type="hidden" />
            <button data-command="search" data-page="1">Search</button>
        </div>
        <div>
            <table class="table">
                <thead>
                    <tr>
                        <th>
                            <button data-sort="CategoryName" data-command="order" class="btn btn-link">
                                Name
                            </button>
                        </th>
                        <th>
                            <button data-sort="Description" data-command="order" class="btn btn-link">
                                Description
                            </button>
                        </th>
                        <th></th>
                    </tr>
                </thead>
                @{await Html.RenderPartialAsync("IndexTable");}
            </table>
        </div>
    </div>
</form>

<script>
    // Personalización para la dirección de ordenamiento
    let sortButtons = document.querySelectorAll('[data-sort]');
    sortButtons.forEach(sb => {
        sb.addEventListener('click', function (event) {
            // Se inicializa el ordenamiento del resto de columnas
            sortButtons.forEach(sb2 => {
                if (sb == sb2) {
                    // Determinar el orden de la columna
                    sb2.dataset.sortdir = sb2.dataset.sortdir === 'asc' ? 'desc' : 'asc';
                }
                else {
                    sb2.dataset.sortdir = '';
                }
            });
            console.log(sb);
        });
    });

    (function formActions(main, params, ajax = false, el = '', process = '') {
        if (document.querySelector(main)) {
            function bindParams(main, params) {
                // Enlace del evento click para los diferentes parámetros
                params.forEach(p => {
                    let actions = document.querySelectorAll(`${main} [data-${p}]`);

                    actions.forEach(a => {
                        a.addEventListener('click', function (event) {
                            //event.preventDefault();
                            let value = this.dataset[p].toLowerCase();

                            // Actualizar el valor
                            let input = document.querySelector(`${main} input[id=${p}]`);
                            input.value = value;
                        });
                    });
                });
            }

            bindParams(main, params); // Enlazar los parámetros de la interfaz

            let form = document.querySelector(main);
            form.setAttribute('method', ajax ? 'post' : 'get');

            // Hacer el envio con AJAX
            if (ajax && el.length > 0) {
                form.addEventListener('submit', async (event) => {
                    event.preventDefault();

                    // Determinar la porción a actualizar
                    const nodes = document.querySelectorAll(`${main} ${el}`);

                    if (nodes.length > 0) {
                        let processElement = document.querySelector(`${process}`);
                        processElement.classList.add('processing'); // Indicador de procesamiento

                        // Determinar el elemento después de donde actualizar
                        const previo = nodes[0].previousElementSibling;
                        let fd = new FormData(form);
                        const response = await fetch(window.location.href, { method: 'post', headers: { 'X-Requested-With': 'fetch' }, body: fd });

                        if (response.ok) {
                            let text = await response.text();

                            // Eliminar los elementos actuales
                            nodes.forEach(n => n.remove());

                            // Se coloca el resultado tomando como base el elemento previo
                            previo.insertAdjacentHTML('afterend', text);
                            bindParams(main, params); // Enlazar los parámetros de la interfaz

                            processElement.classList.remove('processing'); // Indicador de procesamiento
                        }
                    }
                });
            }

            // TODO
            // Deshabilitar interacción
            // Personalizar indicador de progreso
        }
    })('#form1', ['command', 'page', 'sort', 'sortdir'], false, '#result', '#processing');
</script>

<style>
    .processing:before {
        content: attr(data-message);
    }

    [data-sortdir='asc']:after {
        content: "↑";
        color: black;
        font-weight: bold;
        font-size: large;
        margin-left: 0.25em;
    }

    [data-sortdir='desc']:after {
        content: "↓";
        color: black;
        font-weight: bold;
        font-size: large;
        margin-left: 0.25em;
    }
</style>